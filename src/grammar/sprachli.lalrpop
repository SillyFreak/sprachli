use std::str::FromStr;

use crate::ast;

grammar;

pub SourceFile: ast::SourceFile = {
	<declarations:Declaration*> => ast::SourceFile { <> },
}

//////
// declarations

pub Declaration: ast::Declaration = {
	// Use
	<Fn> => ast::Declaration::Fn(<>),
	<Struct> => ast::Declaration::Struct(<>),
	// Mixin
	// Impl
}

pub Visibility: ast::Visibility = {
	=> ast::Visibility::Private,
	"pub" => ast::Visibility::Public,
}

pub Fn: ast::Fn = {
	<visibility:Visibility>
	"fn" <name:Identifier>
	"(" <formal_parameters:CommaSeparated<Identifier>> ")"
	<body:Block> => ast::Fn { <> },
}

pub Struct: ast::Struct = {
	<visibility:Visibility>
	"struct" <name:Identifier>
	<members:StructMembers> => ast::Struct { <> },
}

pub StructMembers: ast::StructMembers = {
	";" => ast::StructMembers::Empty,
	"(" <members:CommaSeparated<Identifier>> ")" ";" => ast::StructMembers::Positional(<>),
	"{" <members:CommaSeparated<Identifier>> "}" => ast::StructMembers::Named(<>),
};

//////
// statements

pub Statement: ast::Statement = {
	Declaration => ast::Statement::Declaration(<>),
	<Expression> ";" => ast::Statement::Expression(<>),
}

//////
// expressions

pub Expression: ast::Expression = {
	Integer => ast::Expression::Integer(<>),
	Identifier => ast::Expression::Identifier(<>),
	Block => ast::Expression::Block(Box::new(<>)),
	If => ast::Expression::If(<>),
	"(" <Expression> ")",
}

pub Block: ast::Block = {
	"{" <statements:Statement*> <expression:Expression?> "}" => ast::Block { <> },
}

pub If: ast::If = {
	<mut then_branches:(<ThenBranch> "else")*>
	<last_then_branch:ThenBranch>
	<else_branch:("else" <Block>)?>
	=> {
		then_branches.push(last_then_branch);
		let else_branch = else_branch.map(Box::new);
		ast::If { then_branches, else_branch }
	},
}

ThenBranch: (ast::Expression, ast::Block) = {
	"if" <Expression> <Block>
}

//////
// misc

CommaSeparated<T>: Vec<T> = { // (1)
	<mut v:(<T> ",")*> <e:T?> => { // (2)
		if let Some(e) = e {
			v.push(e);
		}
		v
	}
}

pub Identifier: String = {
	r"[_a-zA-Z][_a-zA-Z0-9]*" => <>.to_string(),
}

pub Integer: i32 = {
	r"[0-9]+" => i32::from_str(<>).unwrap(),
}

match {
	r"\s*" => { }, // The default whitespace skipping is disabled an `ignore pattern` is specified
	r"//[^\n\r]*[\n\r]*" => { }, // Skip `// comments`
	r"/\*[^*]*\*+(?:[^/*][^*]*\*+)*/" => { },  // Skip `/* comments */`
	_
}