use std::str::FromStr;

use bigdecimal::BigDecimal;

use crate::ast;

grammar;

pub SourceFile: ast::SourceFile = {
	<declarations:Declaration*> => ast::SourceFile { <> },
}

//////
// declarations

pub Declaration: ast::Declaration = {
	// Use
	<Fn> => ast::Declaration::Fn(<>),
	<Struct> => ast::Declaration::Struct(<>),
	// Mixin
	// Impl
}

Visibility: ast::Visibility = {
	=> ast::Visibility::Private,
	"pub" => ast::Visibility::Public,
}

pub Fn: ast::Fn = {
	<visibility:Visibility>
	"fn" <name:Identifier>
	"(" <formal_parameters:CommaSeparated<Identifier>> ")"
	<body:Block> => ast::Fn::new(<>),
}

pub Struct: ast::Struct = {
	<visibility:Visibility>
	"struct" <name:Identifier>
	<members:StructMembers> => ast::Struct::new(<>),
}

StructMembers: ast::StructMembers = {
	";" => ast::StructMembers::Empty,
	"(" <members:CommaSeparated<Identifier>> ")" ";" => ast::StructMembers::Positional(<>),
	"{" <members:CommaSeparated<Identifier>> "}" => ast::StructMembers::Named(<>),
};

//////
// statements

pub Statement: ast::Statement = {
	Declaration => ast::Statement::Declaration(<>),
	<Expression> ";" => ast::Statement::Expression(<>),
}

//////
// expressions

pub Expression: ast::Expression = {
	Equality,
}

pub Equality: ast::Expression = {
	<left:Equality> <operator:EqualityOp> <right:Comparison> => ast::Binary::new_expression(<>),
	Comparison,
}

EqualityOp: ast::BinaryOperator = {
	"==" => ast::BinaryOperator::Equals,
	"!=" => ast::BinaryOperator::NotEquals,
}

pub Comparison: ast::Expression = {
	<left:Comparison> <operator:ComparisonOp> <right:Additive> => ast::Binary::new_expression(<>),
	Additive,
}

ComparisonOp: ast::BinaryOperator = {
	">" => ast::BinaryOperator::Greater,
	">=" => ast::BinaryOperator::GreaterEquals,
	"<" => ast::BinaryOperator::Less,
	"<=" => ast::BinaryOperator::LessEquals,
}

pub Additive: ast::Expression = {
	<left:Additive> <operator:AdditiveOp> <right:Multiplicative> => ast::Binary::new_expression(<>),
	Multiplicative,
}

AdditiveOp: ast::BinaryOperator = {
	"+" => ast::BinaryOperator::Add,
	"-" => ast::BinaryOperator::Subtract,
}

pub Multiplicative: ast::Expression = {
	<left:Multiplicative> <operator:MultiplicativeOp> <right:Unary> => ast::Binary::new_expression(<>),
	Unary,
}

MultiplicativeOp: ast::BinaryOperator = {
	"*" => ast::BinaryOperator::Multiply,
	"/" => ast::BinaryOperator::Divide,
}

pub Unary: ast::Expression = {
	<operator:UnaryOp> <right:Unary> => ast::Unary::new_expression(<>),
	Call,
}

UnaryOp: ast::UnaryOperator = {
	"-" => ast::UnaryOperator::Negate,
	"!" => ast::UnaryOperator::Not,
}

pub Call: ast::Expression = {
	<function:Atomic> "(" <actual_parameters:CommaSeparated<Expression>> ")" => ast::Call::new_expression(<>),
	Atomic,
}

pub Atomic: ast::Expression = {
	Number => ast::Expression::Number(<>),
	String => ast::Expression::String(<>),
	Identifier => ast::Expression::Identifier(<>),
	Block => ast::Expression::Block(<>),
	If => ast::Expression::If(<>),
	"(" <Expression> ")",
}

pub Block: ast::Block = {
	"{" <statements:Statement*> <expression:Expression?> "}" => ast::Block::new(<>),
}

pub If: ast::If = {
	<mut then_branches:(<ThenBranch> "else")*>
	<last_then_branch:ThenBranch>
	<else_branch:("else" <Block>)?>
	=> {
		then_branches.push(last_then_branch);
		ast::If::new(then_branches, else_branch)
	},
}

ThenBranch: (ast::Expression, ast::Block) = {
	"if" <Expression> <Block>
}

//////
// misc

CommaSeparated<T>: Vec<T> = { // (1)
	<mut v:(<T> ",")*> <e:T?> => { // (2)
		v.extend(e);
		v
	}
}

pub Identifier: String = {
	IDENTIFIER => <>.to_string(),
}

pub Number: BigDecimal = {
	NUMBER => BigDecimal::from_str(<>).unwrap(),
}

pub String: String = {
	STRING => <>.to_string(),
}

match {
	// keywords must have priority over identifiers
	"pub", "fn", "struct", "if", "else",
} else {
	r"[_a-zA-Z][_a-zA-Z0-9]*" => IDENTIFIER,
	r"[0-9]+" => NUMBER,
	r#""([^\\"]|\\[\\fnrt"])*""# => STRING,

	r"\s*" => { }, // The default whitespace skipping is disabled an `ignore pattern` is specified
	r"//[^\n\r]*[\n\r]*" => { }, // Skip `// comments`
	r"/\*[^*]*\*+(?:[^/*][^*]*\*+)*/" => { },  // Skip `/* comments */`
	_,
}