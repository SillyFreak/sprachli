use std::str::FromStr;

use crate::ast;

grammar;

pub SourceFile: ast::SourceFile = {
	<declarations:Declaration*> => ast::SourceFile { <> },
}

//////
// declarations

pub Declaration: ast::Declaration = {
	// Use
	<Fn> => ast::Declaration::Fn(<>),
	<Struct> => ast::Declaration::Struct(<>),
	// Mixin
	// Impl
}

Visibility: ast::Visibility = {
	=> ast::Visibility::Private,
	"pub" => ast::Visibility::Public,
}

pub Fn: ast::Fn = {
	<visibility:Visibility>
	"fn" <name:Identifier>
	"(" <formal_parameters:CommaSeparated<Identifier>> ")"
	<body:Block> => ast::Fn { <> },
}

pub Struct: ast::Struct = {
	<visibility:Visibility>
	"struct" <name:Identifier>
	<members:StructMembers> => ast::Struct { <> },
}

StructMembers: ast::StructMembers = {
	";" => ast::StructMembers::Empty,
	"(" <members:CommaSeparated<Identifier>> ")" ";" => ast::StructMembers::Positional(<>),
	"{" <members:CommaSeparated<Identifier>> "}" => ast::StructMembers::Named(<>),
};

//////
// statements

pub Statement: ast::Statement = {
	Declaration => ast::Statement::Declaration(<>),
	<Expression> ";" => ast::Statement::Expression(<>),
}

//////
// expressions

pub Expression: ast::Expression = {
	Equality,
}

pub Equality: ast::Expression = {
	<left:Equality> <operator:EqualityOp> <right:Comparison> => ast::Expression::Binary(Box::new(ast::Binary { <> })),
	Comparison,
}

EqualityOp: ast::BinaryOperator = {
	"==" => ast::BinaryOperator::Equals,
	"!=" => ast::BinaryOperator::NotEquals,
}

pub Comparison: ast::Expression = {
	<left:Comparison> <operator:ComparisonOp> <right:Additive> => ast::Expression::Binary(Box::new(ast::Binary { <> })),
	Additive,
}

ComparisonOp: ast::BinaryOperator = {
	">" => ast::BinaryOperator::Greater,
	">=" => ast::BinaryOperator::GreaterEquals,
	"<" => ast::BinaryOperator::Less,
	"<=" => ast::BinaryOperator::LessEquals,
}

pub Additive: ast::Expression = {
	<left:Additive> <operator:AdditiveOp> <right:Multiplicative> => ast::Expression::Binary(Box::new(ast::Binary { <> })),
	Multiplicative,
}

AdditiveOp: ast::BinaryOperator = {
	"+" => ast::BinaryOperator::Add,
	"-" => ast::BinaryOperator::Subtract,
}

pub Multiplicative: ast::Expression = {
	<left:Multiplicative> <operator:MultiplicativeOp> <right:Unary> => ast::Expression::Binary(Box::new(ast::Binary { <> })),
	Unary,
}

MultiplicativeOp: ast::BinaryOperator = {
	"*" => ast::BinaryOperator::Multiply,
	"/" => ast::BinaryOperator::Divide,
}

pub Unary: ast::Expression = {
	<operator:UnaryOp> <right:Call> => ast::Expression::Unary(Box::new(ast::Unary { <> })),
	Call,
}

UnaryOp: ast::UnaryOperator = {
	"-" => ast::UnaryOperator::Negate,
	"!" => ast::UnaryOperator::Invert,
}

pub Call: ast::Expression = {
	<function:Atomic> "(" <actual_parameters:CommaSeparated<Expression>> ")" => {
		let function = Box::new(function);
		ast::Expression::Call(ast::Call { <> })
	},
	Atomic,
}

pub Atomic: ast::Expression = {
	Integer => ast::Expression::Integer(<>),
	Identifier => ast::Expression::Identifier(<>),
	Block => ast::Expression::Block(Box::new(<>)),
	If => ast::Expression::If(<>),
	"(" <Expression> ")",
}

pub Block: ast::Block = {
	"{" <statements:Statement*> <expression:Expression?> "}" => ast::Block { <> },
}

pub If: ast::If = {
	<mut then_branches:(<ThenBranch> "else")*>
	<last_then_branch:ThenBranch>
	<else_branch:("else" <Block>)?>
	=> {
		then_branches.push(last_then_branch);
		let else_branch = else_branch.map(Box::new);
		ast::If { then_branches, else_branch }
	},
}

ThenBranch: (ast::Expression, ast::Block) = {
	"if" <Expression> <Block>
}

//////
// misc

CommaSeparated<T>: Vec<T> = { // (1)
	<mut v:(<T> ",")*> <e:T?> => { // (2)
		v.extend(e);
		v
	}
}

pub Identifier: String = {
	r"[_a-zA-Z][_a-zA-Z0-9]*" => <>.to_string(),
}

pub Integer: i32 = {
	r"[0-9]+" => i32::from_str(<>).unwrap(),
}

match {
	r"\s*" => { }, // The default whitespace skipping is disabled an `ignore pattern` is specified
	r"//[^\n\r]*[\n\r]*" => { }, // Skip `// comments`
	r"/\*[^*]*\*+(?:[^/*][^*]*\*+)*/" => { },  // Skip `/* comments */`
	_
}